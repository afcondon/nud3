module Examples.Miserables where

import Nud3

import Effect (Effect)
import Examples.Simulations.Model (LesMisRawModel)
import Nud3.Attributes (Attribute(..), centerOriginViewBox, foldAttributes)
import Nud3.Layouts.Simulation (Model)
import Nud3.Layouts.Simulation as Simulation
import Nud3.Types (KeyFunction(..))
import Prelude (Unit, bind, discard, pure, show, unit, ($), (<>))

-- | ForceLayout example

colorByGroup :: Int -> String -- placeholder generated by copilot 
colorByGroup group =
  case group of
    0 -> "#1f77b4"
    1 -> "#ff7f0e"
    2 -> "#2ca02c"
    3 -> "#d62728"
    4 -> "#9467bd"
    5 -> "#8c564b"
    6 -> "#e377c2"
    7 -> "#7f7f7f"
    8 -> "#bcbd22"
    9 -> "#17becf"
    _ -> "#000000"

setUpSimulation :: Unit -> Effect (Simulation.Engine)
setUpSimulation _ = do
  simulator <- Simulation.newEngine Simulation.defaultParams
  
  charge <- Simulation.makeForceManyBody Simulation.forceManyBodyParams
  center <- Simulation.makeForceCenter Simulation.forceCenterParams  

  Simulation.addForce simulator charge
  Simulation.addForce simulator center
  pure simulator


drawForceLayout :: forall r. Simulation.Engine -> Number -> Number -> Model r -> Effect Unit
drawForceLayout simulator width height model = do
  let root = select (SelectorString "div#miserables")
  svg <- addElement root $ Append $ SVG "svg"

  let
    _ = foldAttributes svg
      [ centerOriginViewBox width height
      , Classed "force-layout"
      , Width width
      , Height height
      ]
  linksGroup <- addElement svg $ Append (SVG "g")
  let _ = foldAttributes linksGroup [ Classed "link", StrokeColor "#999", StrokeOpacity 0.6 ]
  
  nodesGroup <- addElement svg $ Append (SVG "g")
  let _ = foldAttributes nodesGroup [ Classed "node", StrokeColor "#fff", StrokeOpacity 1.5 ]

  -- side-effects ahoy, the data in these selections will change as the simulator runs
  simNodes <- Simulation.addNodes
    { simulator
    , nodes: model.nodes
    , key: \d -> d.id
    }

  simLinks <- Simulation.addLinks
    { simulator
    , nodes: simNodes
    , links: model.links
    , key: \d -> d.id
    }

  domNodes <- visualize
    { what: Append (SVG "circle")
    , "data": NewData simNodes
    , parent: nodesGroup
    , key: IdentityKey
    , instructions: Simple [ Radius 5.0, Fill_ \d _ -> colorByGroup d.group ]
    }

  -- now that we have a selection in the DOM we can give the simulator a tick handler to update it
  _ <- Simulation.on simulator $ Simulation.Tick "nodes" domNodes [ CX_ \d _ -> d.x, CY_ \d _ -> d.y ]
  
  -- TODO drag handler would / could go here but it's not applied to the simulator actually, so this needs to be rethought
  -- drag behavior in a simulation will usually involve "reheating" the simulation so that the nodes update to reflect the effect of the drag
  -- _ <- Simulation.on simulator $ Simulation.Drag "nodes" domNodes Simulation.DefaultDragBehavior

  domLinks <- visualize
    { what: Append (SVG "line")
    , "data": NewData simLinks
    , parent: linksGroup
    , key: IdentityKey
    , instructions: Simple
        [ StrokeWidth 1.5
        , StrokeColor "#555"
        , StrokeOpacity 0.4
        , Fill "none"
        , Path_ \l _ -> "M" <> show l.source.x <> "," <> show l.source.y <> "L" <> show l.target.x <> "," <> show l.target.y
        ]
    }

  _ <- Simulation.on simulator $ Simulation.Tick "links" domLinks
    [ X1_ \l _ -> l.source.x
    , Y1_ \l _ -> l.source.y
    , X2_ \l _ -> l.target.x
    , Y2_ \l _ -> l.target.y
    ]

  pure unit
